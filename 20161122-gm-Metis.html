<!DOCTYPE html>
<html>

<head>
  <title>2016/11/22 Group Meeting (Update: Notes for Discussions)</title>
  <meta charset="utf-8" />
  <meta author="Hao-Yung Chan" />
  <style>

    @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono);
    @import url(https://fonts.googleapis.com/css?family=Roboto);

    body {
      font-family: 'Roboto';
    }

    h1, h2, h3 {
      font-family: 'Droid Serif';
      font-weight: normal;
    }

	h1 {
	  font-size: 2em;
	}

	h2 {
	  font-size: 1.6em;
	}

	h3 {
	  font-size: 1.2em;
	}

    .remark-code, .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }

    img {
      margin: 0 auto;
      max-width: 100%;
      max-height: 100%;
    }

	table {
	  width: 100%;
	}

	tr, td {
	  border: solid 1px #000;
	  text-align: center;
	}
  </style>
</head>

<body>
  <textarea id="source">

class: center, middle

# 智慧評語推薦模組開發進度
Hao-Yung Chan, 11/22 group meeting

---

## 前情提要

上次在我的 terminal 上 live demo，做出了：

1. 評語資料的分詞
2. 計算每個詞出現的次數
3. 得出每一筆評與資料在「空間」中的位置
4. 使用 K mean 分群

有一些問題：

1. K mean 不是一個適當的分群方式
2. 評語分詞後產生的詞語清單不受控制

針對第二點，使用自訂詞庫

---

## 使用自訂詞庫

1. 產生自訂詞庫：` ["好","無","不錯","good","線","圖","ok","圓","輔助線","分"] `
2. 計算這些詞在評語中出現的次數
3. 得出在「空間」中的位置
4. 使用 K mean 分群

結果？

---

## 改變分類方式

1. 檢查與是否帶有該評分項目的關鍵字（自訂）
2. 分辨語意為「正」、「負」、「中性」
	* ` "positive" : ["正確","對","Good","good","ok","好","很好","不錯","棒","很棒","非常棒","非常好","蒸蚌"] `
	* ` "negative" : ["不對","不是","Bad","bad","糟","很糟","非常糟","不好","很不好","非常不好","爛","很爛","非常爛"] `

結果？

---

## 測試結果


| / | 正面的 | 中性的 | 負面的|
|-----|-----|-----|-----|
| 有關鍵字| 78 | 304 | 9 |
| 無關鍵字| 1041 | 3892 | 40 | 

---

## 再來要幹嘛

1. Elasticsearch as DB
2. Elasticsearch to 互動式的功能
3. 其他分類方式？


---

## （筆記）咪後討論

### 改用比較專業的資料
1. 使用專業人員（教師、助教、教育與心理方面的專家等）的評語來分析，好過直接用學生的資料來 Mining。
2. 先做好計算機的部分，資料下一階段再接上。
3. 試試看中研院或其他現有的資料庫。

### Bot
1. 透過前面先填寫量化或設計過的問題，最後產出建議的評語。
2. 參考：凱元學長他們最近在做的東西。




  </textarea>

  <script src="./remark/remark-latest.min.js"></script>
  <script>
    var slideshow = remark.create();
	
	var allImg = document.querySelectorAll("img");
	if (allImg.length > 0) {
  	  for (var i = 0; i < allImg.length; ++i) {
	    var h = allImg[i].parentElement.clientHeight;
		allImg[i].style.height = h;
	  }
	}
  </script>
</body>

</html>
